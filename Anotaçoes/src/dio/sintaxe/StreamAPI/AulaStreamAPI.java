import java.util.List;
import java.util.function.BinaryOperator;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.Arrays;
import java.util.stream.*;


/// lambida = variavel/argumento -> acão/retorno
//"stream" (ou fluxo) é uma abstração que permite processar coleções de dados de forma eficiente e declarativa. A ideia central é fornecer uma forma de trabalhar com sequências de elementos (como listas, conjuntos, ou outros dados) em uma maneira que seja mais legível e expressiva, sem ter que lidar diretamente com iterações e loops explícitos.
//functional interfaces abaixo


public class AulaStreamAPI {

    
    public static void main(String[] args) throws Exception {
        
        /* Consumer<T>: Representa uma operação que aceita um argumento do tipo T e não retorna nenhum resultado. É utilizada principalmente para realizar ações ou efeitos colaterais nos elementos do Stream sem modificar ou retornar um valor. */


        List<Integer> numeros = Arrays.asList(1,2,3,4,5);

        Consumer<Integer> imprimirNumeroPar = x -> {
            if(x % 2 == 0) {
                System.out.println(x);

            }


        };

        numeros.stream().forEach(imprimirNumeroPar); // nao precisa do .stream()


        // Supplier<T> =  nao recebe nenhum argumento e retorna um resultado do tipo T, é usada para criar ou fornecer novos objetos de um determinado tipo.
        // diz que usa mt

        Supplier<String> saudacao = () -> "Ola Mundo";


        //posso usar o Supplier para criar uma lista com 5 saudaçoes
        // generate -> nao entendi bem 
        // funciona só com .tolist
        // returns an infinite sequential unordered stream where each element is generated by the provided Supplier. This is suitable for generating constant streams, streams of random elements, etc.

        List<String> listaSauda = Stream.generate(saudacao).limit(5).collect(Collectors.toList());

        //imprimir as saudadçoes geradas
        //for each recebe um consumer

        listaSauda.forEach(l -> System.out.println(l)); // modo reference System.out::println obs: lambda parece melhor



        ///Function<T,R> 
        ///Aceita um argumento do tipo T e retorna um resultado do tipo R

        List<Integer> numeros2 = Arrays.asList(5,4,3,2,1);
        
        Function<Integer, Integer> dobrar = n -> n * 2;

        //map recebe uma function e faz oq ela faz -> mapear de um valor para outro valor 
        //pode usar só toList = map().tolist();

        List<Integer> numerosDobrados = numeros2.stream().map(dobrar).collect(Collectors.toList());
        
        numerosDobrados.forEach(n -> System.out.println(n));

        ///Predicate<T> 
        //aceita um argumento do tipo T e retorna um booleano, usado para filtrar os elementos do stream com base em alguma condição 

        List<String> nomes = Arrays.asList("Gabriel" , "Rebecca" , "Marcos" , "leo" , "Rodrigo" , "Mordekaizer");

        Predicate<String> maisDeCinco = p -> p.length() > 5;

        nomes.stream().filter(maisDeCinco).forEach(p ->  System.out.println(p));


        //BinaryOperator<T>
        //Combina dos argumentos do tipo T e retorna um resultado do mesmo tipo, usado para realizar operaçoes de reduçao em pares de elementos, como somar numers ou combinar objetos.

        List<Integer> numeros3 = Arrays.asList(10,20,30,40,50);


        BinaryOperator<Integer> somarLista = (n1, n2) -> n1 + n2;

        //usando pra somar tudo
        int resultado = numeros3.stream().reduce( 0 , somarLista); 

        System.out.println("soma: " + resultado);



        //existem mais 

        








        


















    }
}
